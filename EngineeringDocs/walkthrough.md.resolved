# Forced Final & Frontend Line-Break Walkthrough

This document details the exact technical pathway of how text is finalized, particularly focusing on the "Forced Final" mechanism and how the frontend determines when to cut off text and move it to the next line.

## 1. The Backend "Forced Final" Pathway

A "Forced Final" occurs when the transcription engine (e.g., Google Speech) forcibly resets its streaming connection. Because streaming APIs have maximum duration limits (or timeout periods), the backend must cleanly cut off the current stream and start a new one to prevent failure.

### The Trigger ([soloModeHandler.js](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/backend/soloModeHandler.js))
1. **Stream Restart**: Google Speech hits its inherent timeout or the stream needs to be refreshed. The backend generates a `meta.forced === true` signal alongside the `transcriptText`.
2. **Audio Recovery Window**: Because a forced restart results in a "decoder gap" (approx 200-500ms of lost audio right before the cut), the backend initiates a **Phase 1 & Phase 2** recovery window.
   - It buffers the forced final text.
   - It captures 2200ms of audio (1400ms PRE-final to catch the gap, and 800ms POST-final).
   - This audio is sent to a recovery stream to transcribe the missing words.
3. **Commitment**: Once recovery completes (or times out), the backend commits the text heavily enriched with any recovered words.
4. **WebSocket Payload**: The backend dispatches a `translation` event to the frontend with the flag \`forceFinal: true\`.
   ```javascript
   processFinalText(recoveredText, { forceFinal: true, sourceLang, targetLang });
   ```

## 2. The Frontend Pathway: When to Cut Off Text

The frontend is responsible for ensuring the user interface remains legible by breaking long continuous transcriptions into separate lines (messages in the history). This is governed by [SentenceSegmenter](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js#8-607) (\[frontend/src/utils/sentenceSegmenter.js\](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js)).

There are two primary ways text gets cut off and moved to the next line: **Auto-Flushing (during a long partial)** and **Final Processing (including Forced Finals)**.

### Path A: Auto-Flushing (Cutting off mid-stream)
As partial text accumulates byte-by-byte from the backend, [processPartial()](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js#80-327) continuously evaluates the text against three core rules to prevent the live text block from growing infinitely:

1. **Rule 1: Sentence Count Limit** (`maxSentences = 10`)
   - If the accumulated text contains 10 or more complete sentences (ending in `.`, `!`, `?`), the segmenter will "flush" the oldest sentences to the history (moving them to the next line visually) to keep the live display manageable.
2. **Rule 2: Character Limit** (`maxChars = 2000`)
   - If the cumulative text exceeds 2000 characters, it forces a flush of all complete sentences to history.
3. **Rule 3: Time Limit** (`maxTimeMs = 15000`)
   - If 15 seconds have passed without a flush and there are complete sentences, they are flushed.

*Safety Mechanisms*: During auto-flushing, the segmenter will **skip** flushing sentences if the partial was updated very recently (< 3 seconds ago) or if the sentence is a short fragment (< 25 characters), assuming the phrase is still being formed.

### Path B: Processing a Final & Forced Final

When the user pauses speaking naturally, or when a **Forced Final** occurs, the backend sends an event with `isPartial: false`. The frontend routes this to `segmenter.processFinal(text, { isForced })`.

1. **Normal Final (Natural Pause)**:
   - The segmenter looks at the `finalText`.
   - **Deduplication**: Because [processPartial()](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js#80-327) might have already auto-flushed parts of this text to the next line via Rules 1-3, [processFinal()](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js#328-564) runs a strict deduplication check. It subtracts any text already in the `flushedText` memory so that only truly *new* text is written to the next line.
   
2. **Forced Final (`forceFinal: true`)**:
   - Because a stream restart occurred, the incoming text might have slight punctuation or casing differences compared to the partials previously flushed.
   - The segmenter uses **Lenient Deduplication**:
     ```javascript
     // from sentenceSegmenter.js processFinal()
     if (isForced) {
       // Normalizes text by removing punctuation and extra spaces 
       // Checks if the forced final is essentially the same as already flushed text
       // If not a duplicate, it immediately pushes the entire block to a NEW line
     }
     ```
   - **The Cut-Off**: A forced final signals the absolute end of the current transcription context. The [SentenceSegmenter](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/utils/sentenceSegmenter.js#8-607) takes the validated text, pushes it out as an array of `newSentences` to the `onFlush` callback, and **completely clears the `liveText`**. 
   - Visually, the [TranslationInterface.jsx](file://wsl.localhost/Ubuntu/home/jkang1643/projects/realtimetranslationapp/frontend/src/components/TranslationInterface.jsx) receives these flushed sentences and adds them to the permanent chat history, creating the distinct "next line" cut-off effect. The UI then waits for the new audio stream to begin generating fresh partials on a new line.

### Summary of the "Cut-Off" Decision Matrix:
- **During continuous speech**: Text is cut off to the next line when it exceeds 10 sentences, 2000 chars, or 15 seconds.
- **On speaker pause (Normal Final)**: Text is cut off to the next line immediately, heavily deduplicated against what was already auto-flushed.
- **On system restart (Forced Final)**: Text is cut off to the next line immediately using lenient deduplication, and the live display is forcefully cleared to make way for the new stream context.
